<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•è¯æŠ„å†™PDFç”Ÿæˆå™¨ - æµ‹è¯•å¥—ä»¶</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .test-pass { color: #10b981; }
        .test-fail { color: #ef4444; }
        .test-pending { color: #f59e0b; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="container mx-auto p-4">
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h1 class="text-2xl font-bold text-gray-900 mb-6">ğŸ§ª å•è¯æŠ„å†™PDFç”Ÿæˆå™¨ - è‡ªåŠ¨åŒ–æµ‹è¯•å¥—ä»¶</h1>
            
            <!-- æµ‹è¯•æ§åˆ¶é¢æ¿ -->
            <div class="mb-6 p-4 bg-blue-50 rounded-lg">
                <div class="flex gap-4 items-center">
                    <button id="run-all-tests" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg">
                        ğŸš€ è¿è¡Œæ‰€æœ‰æµ‹è¯•
                    </button>
                    <button id="run-unit-tests" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg">
                        ğŸ”§ å•å…ƒæµ‹è¯•
                    </button>
                    <button id="run-integration-tests" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg">
                        ğŸ”— é›†æˆæµ‹è¯•
                    </button>
                    <button id="clear-results" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg">
                        ğŸ—‘ï¸ æ¸…ç©ºç»“æœ
                    </button>
                </div>
                <div class="mt-3 text-sm text-gray-600">
                    æ€»æµ‹è¯•: <span id="total-tests">0</span> | 
                    é€šè¿‡: <span id="passed-tests" class="test-pass">0</span> | 
                    å¤±è´¥: <span id="failed-tests" class="test-fail">0</span> | 
                    è¿›è¡Œä¸­: <span id="pending-tests" class="test-pending">0</span>
                </div>
            </div>

            <!-- æµ‹è¯•ç»“æœ -->
            <div id="test-results" class="space-y-2">
                <!-- æµ‹è¯•ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
            </div>
        </div>
    </div>

    <!-- éšè—çš„åº”ç”¨å®ä¾‹ç”¨äºæµ‹è¯• -->
    <div id="hidden-app" style="display: none;">
        <select id="word-source">
            <option value="custom">æ‰‹åŠ¨è¾“å…¥è¯åº“</option>
            <option value="ket">KET æ ¸å¿ƒè¯æ±‡</option>
        </select>
        <textarea id="word-list"></textarea>
        <input type="number" id="repetitions" value="5">
        <input type="number" id="rows-per-page" value="10">
        <input type="number" id="line-spacing" value="60">
        <input type="number" id="font-size" value="22">
        <select id="font-style">
            <option value="Helvetica">æ ‡å‡†å°åˆ·ä½“</option>
            <option value="cursive-standard">æ ‡å‡†æ‰‹å†™ä½“</option>
        </select>
        <select id="trace-opacity-select">
            <option value="180">è¾ƒæ·±</option>
        </select>
        <select id="line-style-select">
            <option value="standard">æ ‡å‡†å››çº¿æ ¼</option>
        </select>
        <button id="generate-pdf">ç”ŸæˆPDF</button>
        <button id="preview-pdf-btn">é¢„è§ˆPDF</button>
    </div>

    <script>
        // æµ‹è¯•æ¡†æ¶
        class TestRunner {
            constructor() {
                this.tests = [];
                this.results = [];
                this.stats = { total: 0, passed: 0, failed: 0, pending: 0 };
            }

            test(name, testFn, category = 'unit') {
                this.tests.push({ name, testFn, category });
            }

            async runAll() {
                this.clearResults();
                for (const test of this.tests) {
                    await this.runTest(test);
                }
                this.updateStats();
            }

            async runCategory(category) {
                this.clearResults();
                const categoryTests = this.tests.filter(t => t.category === category);
                for (const test of categoryTests) {
                    await this.runTest(test);
                }
                this.updateStats();
            }

            async runTest(test) {
                const startTime = Date.now();
                this.logResult(test.name, 'pending', 'è¿è¡Œä¸­...');
                this.stats.pending++;
                this.updateStats();

                try {
                    await test.testFn();
                    const duration = Date.now() - startTime;
                    this.logResult(test.name, 'pass', `é€šè¿‡ (${duration}ms)`);
                    this.stats.pending--;
                    this.stats.passed++;
                } catch (error) {
                    const duration = Date.now() - startTime;
                    this.logResult(test.name, 'fail', `å¤±è´¥: ${error.message} (${duration}ms)`);
                    this.stats.pending--;
                    this.stats.failed++;
                }
                this.updateStats();
            }

            logResult(testName, status, message) {
                const resultsContainer = document.getElementById('test-results');
                const existingResult = document.getElementById(`test-${testName.replace(/\s+/g, '-')}`);
                
                if (existingResult) {
                    existingResult.remove();
                }

                const resultDiv = document.createElement('div');
                resultDiv.id = `test-${testName.replace(/\s+/g, '-')}`;
                resultDiv.className = `p-3 rounded-lg border-l-4 ${
                    status === 'pass' ? 'bg-green-50 border-green-500' :
                    status === 'fail' ? 'bg-red-50 border-red-500' :
                    'bg-yellow-50 border-yellow-500'
                }`;
                resultDiv.innerHTML = `
                    <div class="flex items-center justify-between">
                        <span class="font-medium">${testName}</span>
                        <span class="text-sm ${
                            status === 'pass' ? 'test-pass' :
                            status === 'fail' ? 'test-fail' :
                            'test-pending'
                        }">${message}</span>
                    </div>
                `;
                resultsContainer.appendChild(resultDiv);
            }

            updateStats() {
                this.stats.total = this.stats.passed + this.stats.failed + this.stats.pending;
                document.getElementById('total-tests').textContent = this.stats.total;
                document.getElementById('passed-tests').textContent = this.stats.passed;
                document.getElementById('failed-tests').textContent = this.stats.failed;
                document.getElementById('pending-tests').textContent = this.stats.pending;
            }

            clearResults() {
                document.getElementById('test-results').innerHTML = '';
                this.stats = { total: 0, passed: 0, failed: 0, pending: 0 };
                this.updateStats();
            }

            assert(condition, message) {
                if (!condition) {
                    throw new Error(message);
                }
            }

            assertEqual(actual, expected, message) {
                if (actual !== expected) {
                    throw new Error(`${message}: æœŸæœ› ${expected}, å®é™… ${actual}`);
                }
            }

            assertExists(element, message) {
                if (!element) {
                    throw new Error(`${message}: å…ƒç´ ä¸å­˜åœ¨`);
                }
            }
        }

        // åˆ›å»ºæµ‹è¯•è¿è¡Œå™¨å®ä¾‹
        const testRunner = new TestRunner();

        // å•å…ƒæµ‹è¯•
        testRunner.test('DOMå…ƒç´ å­˜åœ¨æ€§æ£€æŸ¥', () => {
            testRunner.assertExists(document.getElementById('word-source'), 'è¯åº“é€‰æ‹©å™¨');
            testRunner.assertExists(document.getElementById('word-list'), 'å•è¯åˆ—è¡¨');
            testRunner.assertExists(document.getElementById('font-style'), 'å­—ä½“é€‰æ‹©å™¨');
            testRunner.assertExists(document.getElementById('generate-pdf'), 'PDFç”ŸæˆæŒ‰é’®');
        }, 'unit');

        testRunner.test('å­—ä½“é…ç½®å¯¹è±¡éªŒè¯', () => {
            // æ¨¡æ‹ŸWordPrintAppçš„å­—ä½“é…ç½®
            const fontStyles = {
                'Helvetica': { name: 'Helvetica', type: 'normal', description: 'æ ‡å‡†å°åˆ·ä½“' },
                'cursive-standard': { name: 'Times', type: 'italic', letterSpacing: 2, description: 'D\'Nealianæ ‡å‡†æ‰‹å†™ä½“' }
            };
            
            testRunner.assertExists(fontStyles['Helvetica'], 'Helveticaå­—ä½“é…ç½®');
            testRunner.assertExists(fontStyles['cursive-standard'], 'æ‰‹å†™ä½“å­—ä½“é…ç½®');
            testRunner.assertEqual(fontStyles['Helvetica'].type, 'normal', 'Helveticaå­—ä½“ç±»å‹');
            testRunner.assertEqual(fontStyles['cursive-standard'].letterSpacing, 2, 'æ‰‹å†™ä½“å­—æ¯é—´è·');
        }, 'unit');

        testRunner.test('å››çº¿æ ¼æ¯”ä¾‹è®¡ç®—éªŒè¯', () => {
            const fontSize = 22;
            const ascenderHeight = fontSize * 0.8;   // 17.6
            const xHeight = fontSize * 0.8;          // 17.6  
            const descenderHeight = fontSize * 0.6;  // 13.2
            
            testRunner.assertEqual(ascenderHeight, 17.6, 'ä¸Šä¼¸éƒ¨åˆ†é«˜åº¦');
            testRunner.assertEqual(xHeight, 17.6, 'x-heighté«˜åº¦');
            testRunner.assertEqual(descenderHeight, 13.2, 'ä¸‹ä¼¸éƒ¨åˆ†é«˜åº¦');
            
            // éªŒè¯æ€»é«˜åº¦åˆç†æ€§
            const totalHeight = ascenderHeight + xHeight + descenderHeight;
            testRunner.assert(totalHeight > 40 && totalHeight < 60, `æ€»é«˜åº¦åº”åœ¨åˆç†èŒƒå›´: ${totalHeight}`);
        }, 'unit');

        testRunner.test('å•è¯åˆ—è¡¨å¤„ç†', () => {
            const testWords = 'apple\nbanana\ncherry\n\n  \ndog';
            const processed = testWords.split('\n').filter(w => w.trim() !== '');
            
            testRunner.assertEqual(processed.length, 4, 'å¤„ç†åçš„å•è¯æ•°é‡');
            testRunner.assertEqual(processed[0], 'apple', 'ç¬¬ä¸€ä¸ªå•è¯');
            testRunner.assertEqual(processed[3], 'dog', 'æœ€åä¸€ä¸ªå•è¯');
        }, 'unit');

        testRunner.test('æœ¬åœ°å­˜å‚¨åŠŸèƒ½', () => {
            const testData = { fontFamily: 'Times', traceOpacity: 150 };
            localStorage.setItem('wordPrintTest', JSON.stringify(testData));
            
            const retrieved = JSON.parse(localStorage.getItem('wordPrintTest'));
            testRunner.assertEqual(retrieved.fontFamily, 'Times', 'å­—ä½“å®¶æ—å­˜å‚¨');
            testRunner.assertEqual(retrieved.traceOpacity, 150, 'æçº¢é€æ˜åº¦å­˜å‚¨');
            
            localStorage.removeItem('wordPrintTest');
        }, 'unit');

        testRunner.test('æ•°å€¼è¾“å…¥éªŒè¯', () => {
            const testInput = (value, min, max) => {
                const num = parseInt(value);
                return !isNaN(num) && num >= min && num <= max;
            };
            
            testRunner.assert(testInput('5', 1, 20), 'æœ‰æ•ˆçš„é‡å¤æ¬¡æ•°');
            testRunner.assert(testInput('22', 10, 30), 'æœ‰æ•ˆçš„å­—ä½“å¤§å°');
            testRunner.assert(!testInput('0', 1, 20), 'æ— æ•ˆçš„é‡å¤æ¬¡æ•°');
            testRunner.assert(!testInput('50', 10, 30), 'æ— æ•ˆçš„å­—ä½“å¤§å°');
        }, 'unit');

        // é›†æˆæµ‹è¯•
        testRunner.test('å­—ä½“åˆ‡æ¢é›†æˆæµ‹è¯•', async () => {
            const fontSelect = document.getElementById('font-style');
            fontSelect.value = 'cursive-standard';
            
            // æ¨¡æ‹Ÿchangeäº‹ä»¶
            const event = new Event('change');
            fontSelect.dispatchEvent(event);
            
            testRunner.assertEqual(fontSelect.value, 'cursive-standard', 'å­—ä½“é€‰æ‹©å™¨å€¼æ›´æ–°');
        }, 'integration');

        testRunner.test('å•è¯æºåˆ‡æ¢é›†æˆæµ‹è¯•', async () => {
            const wordSourceSelect = document.getElementById('word-source');
            const wordListTextarea = document.getElementById('word-list');
            
            // æ¨¡æ‹ŸKETè¯åº“é€‰æ‹©
            wordSourceSelect.value = 'ket';
            const event = new Event('change');
            wordSourceSelect.dispatchEvent(event);
            
            // ç”±äºæ²¡æœ‰å®é™…çš„appå®ä¾‹ï¼Œæˆ‘ä»¬æµ‹è¯•å…ƒç´ çŠ¶æ€
            testRunner.assertEqual(wordSourceSelect.value, 'ket', 'è¯åº“é€‰æ‹©æ­£ç¡®');
        }, 'integration');

        testRunner.test('PDFå‚æ•°éªŒè¯é›†æˆæµ‹è¯•', () => {
            const params = {
                repetitions: parseInt(document.getElementById('repetitions').value),
                rowsPerPage: parseInt(document.getElementById('rows-per-page').value),
                lineSpacing: parseInt(document.getElementById('line-spacing').value),
                fontSize: parseInt(document.getElementById('font-size').value)
            };
            
            testRunner.assert(params.repetitions >= 1 && params.repetitions <= 20, 'é‡å¤æ¬¡æ•°èŒƒå›´æ­£ç¡®');
            testRunner.assert(params.rowsPerPage >= 5 && params.rowsPerPage <= 20, 'æ¯é¡µè¡Œæ•°èŒƒå›´æ­£ç¡®');
            testRunner.assert(params.lineSpacing >= 30 && params.lineSpacing <= 80, 'è¡Œé—´è·èŒƒå›´æ­£ç¡®');
            testRunner.assert(params.fontSize >= 10 && params.fontSize <= 30, 'å­—ä½“å¤§å°èŒƒå›´æ­£ç¡®');
        }, 'integration');

        testRunner.test('å“åº”å¼è®¾è®¡æµ‹è¯•', () => {
            // æ¨¡æ‹Ÿç§»åŠ¨è®¾å¤‡è§†å£
            const isMobile = window.innerWidth < 768;
            const containers = document.querySelectorAll('.container');
            
            testRunner.assert(containers.length > 0, 'å®¹å™¨å…ƒç´ å­˜åœ¨');
            // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œä¼šæµ‹è¯•å“åº”å¼å¸ƒå±€
        }, 'integration');

        // æ€§èƒ½æµ‹è¯•
        testRunner.test('å¤§é‡å•è¯å¤„ç†æ€§èƒ½æµ‹è¯•', () => {
            const largeWordList = Array.from({length: 1000}, (_, i) => `word${i}`);
            const startTime = Date.now();
            
            const processed = largeWordList.filter(w => w.trim() !== '');
            
            const endTime = Date.now();
            const duration = endTime - startTime;
            
            testRunner.assert(duration < 100, `å¤§é‡å•è¯å¤„ç†è€—æ—¶åº”å°äº100msï¼Œå®é™…${duration}ms`);
            testRunner.assertEqual(processed.length, 1000, 'å¤„ç†å•è¯æ•°é‡æ­£ç¡®');
        }, 'integration');

        // äº‹ä»¶ç›‘å¬å™¨
        document.getElementById('run-all-tests').addEventListener('click', () => {
            testRunner.runAll();
        });

        document.getElementById('run-unit-tests').addEventListener('click', () => {
            testRunner.runCategory('unit');
        });

        document.getElementById('run-integration-tests').addEventListener('click', () => {
            testRunner.runCategory('integration');
        });

        document.getElementById('clear-results').addEventListener('click', () => {
            testRunner.clearResults();
        });

        // é¡µé¢åŠ è½½æ—¶æ˜¾ç¤ºæµ‹è¯•ç»Ÿè®¡
        testRunner.updateStats();
    </script>
</body>
</html>